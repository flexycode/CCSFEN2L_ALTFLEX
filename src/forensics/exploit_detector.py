"""
Exploit Detector Module.

Rule-based detection engine for identifying known blockchain exploit patterns,
specifically focused on flash loan attacks.
"""

import json
import os
from typing import Dict, List, Any, Optional, Set
from datetime import datetime
from dataclasses import dataclass, asdict


@dataclass
class DetectionResult:
    """Result of a single exploit detection check."""
    rule_id: str
    rule_name: str
    is_triggered: bool
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    confidence: float
    details: str
    indicators: List[str]


class ExploitDetector:
    """
    Rule-based exploit detection engine.
    Uses signature matching and heuristics to identify known attack patterns.
    """
    
    # Severity weights for risk scoring
    SEVERITY_WEIGHTS = {
        'CRITICAL': 1.0,
        'HIGH': 0.75,
        'MEDIUM': 0.5,
        'LOW': 0.25
    }
    
    def __init__(self, exploits_db_path: Optional[str] = None):
        """
        Initialize the exploit detector.
        
        Args:
            exploits_db_path: Path to the known exploits JSON database
        """
        self.exploits_db = self._load_exploits_db(exploits_db_path)
        self.known_attacker_addresses = self._extract_attacker_addresses()
        self.suspicious_functions = self._get_suspicious_functions()
        self.lending_protocols = self._get_lending_protocols()
    
    def _load_exploits_db(self, path: Optional[str]) -> Dict:
        """Load the known exploits database."""
        if path is None:
            # Try default path
            default_paths = [
                'data/flash_loan_exploits.json',
                '../data/flash_loan_exploits.json',
                '../../data/flash_loan_exploits.json'
            ]
            for p in default_paths:
                if os.path.exists(p):
                    path = p
                    break
        
        if path and os.path.exists(path):
            with open(path, 'r') as f:
                return json.load(f)
        
        # Return default structure if no database found
        return {
            'known_exploits': [],
            'detection_rules': {
                'flash_loan_indicators': [],
                'suspicious_functions': [],
                'lending_protocols': []
            }
        }
    
    def _extract_attacker_addresses(self) -> Set[str]:
        """Extract all known attacker addresses from the database."""
        addresses = set()
        for exploit in self.exploits_db.get('known_exploits', []):
            for addr in exploit.get('attacker_addresses', []):
                addresses.add(addr.lower())
        return addresses
    
    def _get_suspicious_functions(self) -> List[str]:
        """Get list of suspicious function signatures."""
        return self.exploits_db.get('detection_rules', {}).get('suspicious_functions', [
            'flashLoan', 'flashBorrow', 'executeOperation', 
            'onFlashLoan', 'uniswapV2Call', 'pancakeCall'
        ])
    
    def _get_lending_protocols(self) -> List[str]:
        """Get list of known lending protocol addresses."""
        return self.exploits_db.get('detection_rules', {}).get('lending_protocols', [])
    
    # =========================================================================
    # External Blacklist Integration (Sprint 3 - SEC-P2-011)
    # =========================================================================
    
    def _load_external_blacklists(self) -> Dict[str, Set[str]]:
        """
        Load external blacklist sources.
        
        Returns categorized blacklist addresses:
        - ofac_sanctioned: OFAC SDN list addresses
        - known_phishers: Known phishing addresses
        - known_mixers: Known mixer/tumbler addresses
        - community_reported: Community-reported malicious addresses
        """
        return {
            'ofac_sanctioned': self._get_ofac_addresses(),
            'known_phishers': self._get_phisher_addresses(),
            'known_mixers': self._get_mixer_addresses(),
            'community_reported': set(),  # Would be loaded from external source
        }
    
    def _get_ofac_addresses(self) -> Set[str]:
        """
        Get OFAC sanctioned cryptocurrency addresses.
        
        Note: In production, this should fetch from an official OFAC API
        or maintained database. These are example sanctioned addresses.
        """
        # Example sanctioned addresses (Tornado Cash related)
        return {
            "0x8589427373d6d84e98730d7795d8f6f8731fda16",
            "0x722122df12d4e14e13ac3b6895a86e84145b6967",
            "0xdd4c48c0b24039969fc16d1cdf626eab821d3384",
            "0xd90e2f925da726b50c4ed8d0fb90ad053324f31b",
            "0xd96f2b1c14db8458374d9aca76e26c3d18364307",
        }
    
    def _get_phisher_addresses(self) -> Set[str]:
        """
        Get known phishing addresses.
        
        Note: In production, fetch from Etherscan labels API or
        community-maintained lists.
        """
        # Example known phishing addresses
        return {
            "0x0000000000000000000000000000000000000000",  # Zero address (burn)
            # Add more as identified
        }
    
    def _get_mixer_addresses(self) -> Set[str]:
        """
        Get known mixer/tumbler addresses.
        
        Addresses associated with mixing services that obscure fund origins.
        """
        return {
            # Tornado Cash contracts
            "0x722122df12d4e14e13ac3b6895a86e84145b6967",  # Tornado Cash Router
            "0xd90e2f925da726b50c4ed8d0fb90ad053324f31b",  # Tornado Cash 0.1 ETH
            "0x12d66f87a04a9e220743712ce6d9bb1b5616b8fc",  # Tornado Cash 1 ETH
            "0x47ce0c6ed5b0ce3d3a51fdb1c52dc66a7c3c2936",  # Tornado Cash 10 ETH
            "0xa160cdab225685da1d56aa342ad8841c3b53f291",  # Tornado Cash 100 ETH
        }
    
    def check_external_blacklists(self, address: str) -> Dict[str, Any]:
        """
        Check an address against all external blacklists.
        
        Args:
            address: Ethereum address to check
            
        Returns:
            Dictionary with blacklist check results
        """
        addr_lower = address.lower()
        blacklists = self._load_external_blacklists()
        
        matches = {}
        is_blacklisted = False
        
        for list_name, addresses in blacklists.items():
            if addr_lower in addresses:
                matches[list_name] = True
                is_blacklisted = True
            else:
                matches[list_name] = False
        
        # Determine severity based on blacklist type
        if matches.get('ofac_sanctioned'):
            severity = 'CRITICAL'
            risk_category = 'Sanctioned Address'
        elif matches.get('known_phishers'):
            severity = 'HIGH'
            risk_category = 'Known Phisher'
        elif matches.get('known_mixers'):
            severity = 'MEDIUM'
            risk_category = 'Mixer/Tumbler'
        elif matches.get('community_reported'):
            severity = 'MEDIUM'
            risk_category = 'Community Reported'
        else:
            severity = 'NONE'
            risk_category = None
        
        return {
            'address': address,
            'is_blacklisted': is_blacklisted,
            'severity': severity,
            'risk_category': risk_category,
            'blacklist_matches': matches,
            'checked_at': datetime.now().isoformat()
        }
    
    def get_comprehensive_address_risk(self, address: str) -> Dict[str, Any]:
        """
        Get comprehensive risk assessment combining all blacklist checks.
        
        Combines:
        - Known attacker database (internal)
        - External blacklists (OFAC, phishers, mixers)
        
        Args:
            address: Ethereum address to check
            
        Returns:
            Comprehensive risk assessment
        """
        # Internal check
        internal_result = self.check_address(address)
        
        # External blacklist check
        external_result = self.check_external_blacklists(address)
        
        # Combine results
        is_high_risk = internal_result['is_known_attacker'] or external_result['is_blacklisted']
        
        # Determine overall severity
        if internal_result['is_known_attacker']:
            overall_severity = 'CRITICAL'
        elif external_result['severity'] != 'NONE':
            overall_severity = external_result['severity']
        else:
            overall_severity = 'NONE'
        
        return {
            'address': address,
            'is_high_risk': is_high_risk,
            'overall_severity': overall_severity,
            'internal_check': {
                'is_known_attacker': internal_result['is_known_attacker'],
                'exploit_info': internal_result.get('exploit_info')
            },
            'external_check': {
                'is_blacklisted': external_result['is_blacklisted'],
                'risk_category': external_result['risk_category'],
                'blacklist_matches': external_result['blacklist_matches']
            },
            'checked_at': datetime.now().isoformat()
        }
    
    def detect_all(self, transaction_data: Dict[str, Any]) -> List[DetectionResult]:
        """
        Run all detection rules on a transaction.
        
        Args:
            transaction_data: Dictionary with transaction details
        
        Returns:
            List of detection results for each rule
        """
        results = []
        
        # Run each detection rule
        results.append(self._check_known_attacker(transaction_data))
        results.append(self._check_large_value(transaction_data))
        results.append(self._check_high_gas(transaction_data))
        results.append(self._check_same_block_pattern(transaction_data))
        results.append(self._check_lending_protocol_interaction(transaction_data))
        results.append(self._check_flash_loan_indicator(transaction_data))
        
        return results
    
    def analyze(self, transaction_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Full analysis of a transaction with aggregated results.
        
        Args:
            transaction_data: Dictionary with transaction details
        
        Returns:
            Analysis summary with risk score and triggered rules
        """
        results = self.detect_all(transaction_data)
        
        # Calculate overall risk score
        triggered_rules = [r for r in results if r.is_triggered]
        
        if not triggered_rules:
            risk_score = 0.0
            risk_level = 'SAFE'
        else:
            # Weight by severity
            total_weight = sum(
                self.SEVERITY_WEIGHTS.get(r.severity, 0.5) * r.confidence 
                for r in triggered_rules
            )
            risk_score = min(total_weight / len(results), 1.0)
            
            # Determine risk level
            if risk_score >= 0.8:
                risk_level = 'CRITICAL'
            elif risk_score >= 0.6:
                risk_level = 'HIGH'
            elif risk_score >= 0.4:
                risk_level = 'MEDIUM'
            else:
                risk_level = 'LOW'
        
        return {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'is_suspicious': risk_score >= 0.4,
            'triggered_rules': [asdict(r) for r in triggered_rules],
            'all_rules_checked': len(results),
            'analysis_timestamp': datetime.now().isoformat(),
            'transaction': transaction_data.get('tx_hash', 'unknown')
        }
    
    def _check_known_attacker(self, tx: Dict) -> DetectionResult:
        """Check if address is a known attacker."""
        from_addr = tx.get('from_address', '').lower()
        to_addr = tx.get('to_address', '').lower()
        
        is_known = from_addr in self.known_attacker_addresses or \
                   to_addr in self.known_attacker_addresses
        
        indicators = []
        if from_addr in self.known_attacker_addresses:
            indicators.append(f"From address {from_addr[:10]}... is known attacker")
        if to_addr in self.known_attacker_addresses:
            indicators.append(f"To address {to_addr[:10]}... is known attacker")
        
        return DetectionResult(
            rule_id='KNOWN_ATTACKER',
            rule_name='Known Attacker Address',
            is_triggered=is_known,
            severity='CRITICAL' if is_known else 'LOW',
            confidence=1.0 if is_known else 0.0,
            details='Address matches known exploit attacker database' if is_known else 'No known attacker match',
            indicators=indicators
        )
    
    def _check_large_value(self, tx: Dict) -> DetectionResult:
        """Check for unusually large transaction value."""
        value = float(tx.get('value_eth', 0))
        threshold = 100  # 100 ETH
        
        is_large = value > threshold
        
        return DetectionResult(
            rule_id='LARGE_VALUE',
            rule_name='Large Value Transfer',
            is_triggered=is_large,
            severity='HIGH' if value > 1000 else 'MEDIUM' if is_large else 'LOW',
            confidence=min(value / 1000, 1.0) if is_large else 0.0,
            details=f'Transaction value: {value:.2f} ETH (threshold: {threshold} ETH)',
            indicators=[f'Value {value:.2f} ETH exceeds threshold'] if is_large else []
        )
    
    def _check_high_gas(self, tx: Dict) -> DetectionResult:
        """Check for unusually high gas usage."""
        gas_used = float(tx.get('gas_used', 0))
        gas_price = float(tx.get('gas_price_gwei', 0))
        
        gas_threshold = 500000
        price_threshold = 50  # gwei
        
        is_high_gas = gas_used > gas_threshold
        is_high_price = gas_price > price_threshold
        is_triggered = is_high_gas or is_high_price
        
        indicators = []
        if is_high_gas:
            indicators.append(f'Gas used: {gas_used:,.0f} (threshold: {gas_threshold:,})')
        if is_high_price:
            indicators.append(f'Gas price: {gas_price:.0f} gwei (threshold: {price_threshold})')
        
        return DetectionResult(
            rule_id='HIGH_GAS',
            rule_name='High Gas Usage/Price',
            is_triggered=is_triggered,
            severity='MEDIUM',
            confidence=0.6 if is_triggered else 0.0,
            details='Complex transaction or gas price manipulation detected' if is_triggered else 'Normal gas usage',
            indicators=indicators
        )
    
    def _check_same_block_pattern(self, tx: Dict) -> DetectionResult:
        """Check for same-block transaction patterns (flash loan indicator)."""
        is_flash_loan = tx.get('is_flash_loan', False)
        same_block_txs = tx.get('same_block_tx_count', 1)
        
        is_triggered = is_flash_loan or same_block_txs > 1
        
        return DetectionResult(
            rule_id='SAME_BLOCK',
            rule_name='Same Block Pattern',
            is_triggered=is_triggered,
            severity='HIGH' if is_flash_loan else 'MEDIUM',
            confidence=0.8 if is_flash_loan else (0.5 if same_block_txs > 1 else 0.0),
            details='Flash loan pattern detected - borrow and repay in same block' if is_triggered else 'No same-block pattern',
            indicators=['Flash loan indicator present'] if is_flash_loan else []
        )
    
    def _check_lending_protocol_interaction(self, tx: Dict) -> DetectionResult:
        """Check for interaction with known lending protocols."""
        to_addr = tx.get('to_address', '').lower()
        
        is_lending = to_addr in [p.lower() for p in self.lending_protocols]
        
        return DetectionResult(
            rule_id='LENDING_PROTOCOL',
            rule_name='Lending Protocol Interaction',
            is_triggered=is_lending,
            severity='LOW',  # Not inherently suspicious, just informational
            confidence=0.3 if is_lending else 0.0,
            details='Transaction interacts with known lending protocol' if is_lending else 'No lending protocol interaction',
            indicators=[f'Interacts with lending protocol: {to_addr[:10]}...'] if is_lending else []
        )
    
    def _check_flash_loan_indicator(self, tx: Dict) -> DetectionResult:
        """Check explicit flash loan indicator from transaction data."""
        is_flash = tx.get('is_flash_loan', False)
        is_malicious = tx.get('is_malicious', False)
        
        is_triggered = is_flash and is_malicious
        
        return DetectionResult(
            rule_id='FLASH_LOAN_ATTACK',
            rule_name='Flash Loan Attack Pattern',
            is_triggered=is_triggered,
            severity='CRITICAL' if is_triggered else 'LOW',
            confidence=0.95 if is_triggered else (0.4 if is_flash else 0.0),
            details='Transaction matches flash loan attack pattern' if is_triggered else 'No flash loan attack pattern',
            indicators=['Confirmed flash loan attack indicators'] if is_triggered else []
        )
    
    def check_address(self, address: str) -> Dict[str, Any]:
        """
        Quick check if an address is known malicious.
        
        Args:
            address: Ethereum address to check
        
        Returns:
            Result dictionary with match info
        """
        addr_lower = address.lower()
        is_known = addr_lower in self.known_attacker_addresses
        
        # Find matching exploit info
        matching_exploit = None
        if is_known:
            for exploit in self.exploits_db.get('known_exploits', []):
                if addr_lower in [a.lower() for a in exploit.get('attacker_addresses', [])]:
                    matching_exploit = exploit
                    break
        
        return {
            'address': address,
            'is_known_attacker': is_known,
            'exploit_info': matching_exploit,
            'checked_at': datetime.now().isoformat()
        }
    
    def get_known_exploits(self) -> List[Dict]:
        """Get all known exploits from the database."""
        return self.exploits_db.get('known_exploits', [])
    
    def get_detection_rules(self) -> Dict:
        """Get the detection rules configuration."""
        return self.exploits_db.get('detection_rules', {})


if __name__ == "__main__":
    # Demo
    detector = ExploitDetector()
    print(f"Exploit Detector initialized with {len(detector.known_attacker_addresses)} known attacker addresses.")
    
    # Test with known attacker
    test_address = "0xb66cd966670d962C227B3EABA30a872DbFb995db"  # Euler attacker
    result = detector.check_address(test_address)
    print(f"\nChecking {test_address[:20]}...")
    print(f"Is known attacker: {result['is_known_attacker']}")
    if result['exploit_info']:
        print(f"Exploit: {result['exploit_info']['name']}")
